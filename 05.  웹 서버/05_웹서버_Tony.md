# 2부 : HTTP 아키텍처

- HTTP 서버, 프락시, 캐시, 게이트웨이, 로봇 애플리케이션

#### 5장 웹서버

- 웹 서버 아키텍처에 대해 개략적으로 설명

#### 6장 프락시

- HTTP 클라이언트와 연결되어
- HTTP 서비스와 제어를 위한 플랫폼 처럼 동작하는
- 중개서버, HTTP 프락시 서버

#### 7장 캐시

- 웹 캐시의 과학에 대해 깊이 파고 든다
- 웹 캐시 : 많이 찾는 문서에 대한 지역 사본
- 트래픽을 줄이고 성능을 개선하는 장치

#### 8장 통합점

- 게이트웨이, 터널, 릴레이
  - SSL 보안 프로토콜 등, 서로 다른 프로토콜을 사용하는 소프트웨어들 간에
  - HTTP로 상호작용을 할 수 있게 해주는 애플리케이션들을 설명

#### 9장 웹 로봇

- 웹 클라이언트를 통해 이 파트에서 설명한 HTTP 아키텍처를 정리

#### 10장 HTTP/2.0 - 2021. 11. 07. 진행

- HTTP/1.1의 성능 문제를 개선한 새로운 프로토콜인 HTTP/2.0을 소개

# 5장. 웹서버

#### 이 장에서 다룰 내용

- 여러 종류의 소프트웨어 및 하드웨어 웹 서버에 대해 조사
- HTTP 통신을 진단해주는 간단한 웹 서버를 펄(Perl)로 작성해본다
- 어떻게 웹 서버가 HTTP 트랜잭션을 처리하는지 단계별로 설명한다

## 5.1 다채로운 웹 서버

```javascript
const 웹서버 = (HTTP 요청) => {
    // 처리
    return 응답;
}
```

- 웹서버
  - 웹 서버 소프트웨어 + 웹페이지 제공에 특화된 장비
- 다양한 웹서버

  1. 10줄 짜리 작은 펄 스크립트 웹 서버
  2. 50메가 바이트, 안전한 상용엔진
  3. 아주 작은 기판 위의 서버

- 모든 웹 서버는 리소스에 대한 HTTP 요청을 받아서 콘텐츠를 클라이언트에게 돌려준다

### 5.1.1 웹 서버 구현

#### 웹서버

- HTTP 및 그와 관련된 TCP 처리를 구현한 것이다.
- 자신이 제공하는 리소스 관리
- 웹 서버 설정, 통제, 확장하기 위한 관리 기능을 제공
- HTTP 프로토콜을 구현
- TCP 커넥션 관리에 대한 책임을 운영체제와 나눠갖는다.

#### 운영체제가 제공하는 것들

- 컴퓨터 시스템의 하드웨어를 관리
- TCP/IP 네트워크 지원
- 웹 리소스를 유지하기 위한 파일 시스템
- 현재 연산 활동을 제어하기 위한 프로세스 관리

#### 웹서버의 여러가지 형태

- 다목적 소프트웨어 웹 서버를 표준 컴퓨터 시스템에 설치하고 실행할 수 있음
- IOT 같이 판매하는 전자 기기안에 몇 개의 컴퓨터 칩만으로 구현된 웹 서버를 내장 => 관리 콘솔로 제공

### 5.1.2 다목적 소프트웨어 웹 서버

<details>
<summary>웹 서버별 점유율</summary>

- https://ko.hostadvice.com/marketshare/server/
- 2021년
  - Apache : 40.22%
  - nginx : 27.70%
  - IIS : 11.04%
- 웹 서버별 장단점
  - https://server-talk.tistory.com/296
  - Apache
    - 장점
      - 오픈소스, 무료
      - 다양한 모듈 제공
      - 확장성이 좋음
      - 보안 수준이 높음
    - 단점
      - 많은 기능들로 인해 느림
      - 오버헤드가 발생
  - Nginx
    - 장점
      - 오픈소스, 무료
      - Apache에 비해 가벼움
      - 프록시 기능이 뛰어남
    - 단점
      - 확장 모듈이 Apache에 비해 적음
  - IIS
    - 장점
      - GUI 제공
      - ASP, MSSQL 등과 같은 다른 Microsoft 서비스와 쉽게 통합 가능
    - 단점
      - 비쌈
      - Windows server에서만 동작
      - 느림
  - 웹서버 vs. WAS
    - https://velog.io/@gth1123/Web-server-vs-WAS
    - https://rlg1133.tistory.com/91

</details>

#### 질문

- IIS의 점유율은 왜 계속 떨어질까?
- 각 웹서버의 특징 및 장단점

### 5.1.3. 임베디드 웹 서버

- 제품에 내장될 목적으로 만들어진 작은 웹서버
  - 프린터나 가전제품의 동글
    - https://terms.naver.com/entry.naver?docId=845527&cid=42346&categoryId=42346
  - 책에 있는 임베디드 웹서버 두 개 다 접속 안 됨

## 5.2 간단한 펄 웹 서버

- 완전한 기능을 갖춘 HTTP 서버를 만들려면 할 일이 많음

  - 아파치 웹서버 코어는 50,000줄이 넘는 코드로 되어 있고
  - 부가적인 처리 모듈들을 더 하면 훨씬 커진다

- HTTP/1.1의 기능들을 지원하려면, 풍부한 리소스 지원, 가상 호스팅, 접근 제어, 로깅, 설정, 모니터링, 그 외 성능을 위한 각종 기능들이 필요
- 그러나 최소한으로 기능하는 HTTP 서버라면 30줄 이하 펄(Perl) 코드로도 만들 수 있다.
  - node.js도 간단하게 만들 수 있지만 node.js 자체에서 이미 많은 코드를 포함하고 있을 것 같다
- 펄(Perl) 이란 ?
  - 펄(Perl)은 래리 월이 만든 인터프리터 방식의 프로그래밍 언어 혹은 그 인터프리터 소프트웨어를 가리킨다
  - 자바스크립트도 인터프리터언어 기반이지만 필요에 따라 V8엔진에서 컴파일 하기도 한다
    - https://oowgnoj.dev/review/advanced-js-1
    - https://hashcode.co.kr/questions/7560/javascript-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%96%B8%EC%96%B4%EC%9D%B8%EA%B0%80%EC%9A%94-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%EC%96%B8%EC%96%B4%EC%9D%B8%EA%B0%80%EC%9A%94

## 5.3 진짜 웹 서버가 하는 일

#### 웹서버가 공통적으로 하는 일들

1. 커넥션을 맺는다 -- 클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다.
2. 요청을 받는다 -- HTTP 요청 메세지를 네트워크로부터 읽어 들인다
3. 요청을 처리한다 -- 요청 메세지를 해석하고 행동을 취한다
4. 리소스에 접근한다 -- 메세지에서 지정한 리소스에 접근한다
5. 응답을 만든다 -- 올바른 헤더를 포함한 HTTP 응답 메세지를 생성한다
6. 응답을 보낸다 -- 응답을 클라이언트에게 돌려준다
7. 트랜잭션을 로그로 남긴다 -- 로그파일에 트랜잭션 완료에 대한 기록을 남긴다

## 5.4 단계 1: 클라이언트 커넥션 수락

- 클라이언트가 이미 서버에 대해 열려있는 지속적 커넥션을 갖고 있다면, 클라이언트는 요청을 보내기 위해 그 커넥션을 사용할 수 있다
- 그렇지 않다면, 클라이언트는 서버에 대한 새 커넥션을 열 필요가 있다

### 5.4.1 새 커넥션 다루기

(클라이언트) TCP 커넥션 요청
-> (웹서버) 커넥션 맺고 TCP커넥션에서 IP 주소 추출, 어떤 클라이언트가 있는지 확인 - TCP 커넥션 인터페이스와 자료구조는 운영체제 마다 다름

- 웹 서버는 어떤 커넥션이든 마음대로 거절하거나 즉시 닫을 수 있다
  - 클라이언트의 IP 주소나 호스트명이 인가되지 않았거나 악의적이라고 알려진 것의 경우 커넥션을 닫는다
    - 네이버에서 크롤링을 자주하면 차단된다

### 5.4.2 클라이언트 호스트 명 식별

'역방향 DNS(reverse DNS)' : 클라이언트의 IP 주소 -> 클라이언트의 호스트 명(변환)

- Domain Name System

클라이언트 호스트명 사용

- 구체적인 접근 제어
- 로깅

hostname lookup

- 웹 트랜잭션을 느려지게 할 수 있음
- 사용하더라도 특정 콘텐츠에 대해서만 켜놓음

### 5.4.3 ident를 통해 클라이언트 사용자 알아내기

몇몇 웹서버는 IETF ident 프로토콜을 지원

- ident 프로토콜 : 서버에게 어떤 사용자 이름이 HTTP 커넥션을 초기화 했는지 찾아낼 수 있게 해줌

  - 웹 서버 로깅에서 유용

- 클라이언트에서 이걸 허용하는게 이상한거 아닌가?

## 5.5 단계 2 : 요청 메세지 수신

커넥션에 데이터 도착 -> (웹서버) 네트워크 커넥션 - 데이터 읽고 파싱 - 요청메시지 구성

#### 웹 서버에서 요청 메세지 파싱

- 요청줄을 파싱
  - 요청 메서드, 지정된 리소스의 식별자(URI), 버전 번호를 찾음
  - 각 값은 스페이스 한 개로 구분, 요청줄은 캐리지 리턴 줄바꿈(CRLF) 문자열로 끝남
- 메세지 헤더를 읽음, 각 메세지 헤더는 CRLF로 끝남
- 요청 본문이 있다면 읽음 - 길이는 Content-Length 헤더로 정의 됨

### 5.5.1 메세지의 내부 표현

- 요청 메세지를 쉽게 다룰 수 있도록 내부의 자료 구조에 저장

### 5.5.2 커넥션 입력/출력 처리 아키텍처

- 고성능 웹 서버는 수천 개의 커넥션을 동시에 열 수 있도록 지원
- 이 커넥션들은 웹서버가 전 세계의 클라이언트들과 각각 한 개 이상의 커넥션을 통해 통신할 수 있게 해준다
- 웹 서버들은 항상 새 요청을 주시하고 있다
- 웹 서버 아키텍처의 차이에 따라 요청을 처리하는 방식도 달라진다

#### 단일 스레드(그림 5-7a)

- 한번에 하나씩 요청을 처리
- 트랜잭션이 완료되면, 다음 커넥션이 처리
- 처리 도중 다른 커넥션은 무시 됨 - 심각한 성능 문제를 만들어 냄

#### 멀티 프로세스와 멀티스레드 웹서버(그림 5-7b)

여러 요청을 동시에 처리하기 위해 여러개의 프로세스 혹은 고효율 스레드를 할당

- 프로세스와 스레드는 필요할 때 마다 만들 수도 있고 미리 만들어질 수 있다
  - 스레드가 미리 생성되는 시스템을 작업자 풀(worker pool) 시스템이라고 부르는데, 왜냐하면 스레드들의 집합이 수행할 작업을 풀(pool)에서 기다리기 때문
- 너무 많은 프로세스나 스레드는 메모리나 시스템 리소스를 소비
  - 최대 개수에 제한을 걸음

#### 다중 I/O 서버(그림 5-7c)

- 대량의 커넥션을 지원하기 위해, 많은 웹서버는 다중 아키텍처를 채택
- 모든 커넥션은 동시에 그 활동을 감시 당함
- 커넥션의 상태가 바뀌면(데이터를 사용할 수 있게 되거나 에러가 발생) 그 커넥션에 대해 작은 양의 처리가 수행 됨
  - 그 처리가 완료되면 커넥션은 다음번 상태 변경을 위해 열린 커넥션 목록으로 돌아감
- 어떤 커넥션에 대해 작업을 수행하는 것 -> 그 커넥션에 실제로 해야할 일이 있을 때
- 스레드와 프로세스는 유휴 상태의 커넥션에 매여 기다리느라 리소스를 낭비하지 않음

#### 다중 멀티 스레드 웹 서버(그림 5-7d)

- 몇몇 시스템은 자신의 컴퓨터 플랫폼에 올라와 있는 CPU 여러 개의 이점을 살리기 위해 멀티스레딩과 다중화(multiplexing)를 결합한다.
  - 이게 세션 클러스터링인건가? 물어봐야겠다
- 여러개의 스레드(보통 하나의 물리적 프로세스)는 각각 열려있는 커넥션을 감시하고 각 커넥션에 대해 조금씩 작업을 수행

#### 각 웹 서버들의 아키텍쳐 분류하기

- 질문해서 물어보자

#### 이벤트 기반 non-blocking I/O 모델 - node.js

- https://node-js.tistory.com/27

#### 웹서버들의 특징과 종류

- https://soyeondev.tistory.com/147

## 5.6 단계 3 : 요청 처리

- 웹 서버가 요청을 받으면, 서버는 요청으로 부터 메서드, 리소스, 헤더, (본문) 을 얻어내어 처리
  - POST를 비롯한 몇몇 메서드는 요청 메세지에 엔터티 본문이 있을 것을 요구
  - 그 외 OPTIONS를 비롯한 다수의 메서드는 요청에 본문이 있는 것을 허용하되 요구하지는 않는다.
  - 많지는 않지만 GET과 같이 요청 메세지에 엔터티 본문이 있는 것을 금지하는 메서듣도 있다
- 요청 처리에 대한 자세한 것은 이 책 전반적으로 다룬다

## 5.7 단계 4 : 리소스의 매핑과 접근

- 웹 서버는 리소스 서버다
  - HTML 페이지나 JPEG 이미지 같은 미리 만들어진 콘텐츠를 제공
  - 서버위에서 동작하는 리소스 생성 어플리케이션을 통해 만들어진 동적 콘텐츠도 제공
  - URI에 대응하는 알맞은 콘텐츠를 찾아서 그 콘텐츠의 원천을 식별해야 함

### 5.7.1 Docroot

웹 서버는 여러 종류의 리소스 매핑을 지원

- 가장 단순한 형태 : URI를 웹 서버의 파일 시스템 안에 있는 파일 이름으로 사용하는 것
- 성숙한 웹 서버는 도메인/../ 같은 URI를 허용하지 않는다

#### 가상 호스팅된 docroot

- 가상호스팅 웹 서버는 각 사이트에 그들만의 분리된 문서 루트를 주는 방법으로
- 한 웹서버에서 여러개의 웹사이트를 호스팅 함
  - www.joes-hardware.com
    - /docs/joe/index.html
  - www.marys-antiques.com
    - /docs/mary/index.html

```
// 아파치 웹 서버 가상 호스트 docroot 설정
<Virtual Host www.joes-hardware.com>
    ServerName www.joes-hardware.com
    DocumentRoot /docs/joe
    TransferLog /logs/joe.access_log
    ErrorLog /logs/joe.error_log
</VirtualHost>
```

- 가상호스팅에 대한 자세한 내용 : 18장

#### 사용자 홈 디렉터리 docroots

- docroots의 또 다른 대표적인 활용
  - 한 대의 웹서버에서 각자 개인의 웹사이트를 만들 수 있도록 해주는 것
  - 블로그, 카페 등

### 5.7.2 디렉터리 목록

- 경로가 파일이 아닌 디렉터리를 가리키는 요청을 받는 경우
  - 1. 에러를 반환
  - 2. 디렉터리 대신 특별한 'index' 파일을 반환 -> index.html, default.asp
  - 3. 디렉터리를 탐색해서 그 내용을 담은 HTML 페이지를 반환
  - 대부분의 웹 서버는 요청 URL에 대응되는 디렉터리 안에서 index.html 파일을 찾아서 반환함
    - 웹 서버에서 별도로 설정도 가능
    - 열거 기능이 켜져 있다면 발견할 수 없는 파일도 드러나게 될 수 있음

### 5.7.3 동적 콘텐츠 리소스 매핑

- URL를 동적 리소스에 매핑할 수도 있음

### 5.7.4 서버사이드 인클루드(Server-Side Includes, SSI)

- 서버는 리소소의 콘텐츠를 클라이언트에게 보내기 전에 처리한다
  - 서버 웹 어플리케이션 - php, asp, jsp, express 등

### 5.7.5 접근 제어

- 리소스에 접근 제어를 할당할 수 있음
  - IP 주소에 근거하여 접근 제어
  - 리소스에 접근하기 위한 비밀번호
  - 12장 참고
