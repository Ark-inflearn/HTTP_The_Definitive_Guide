# 5장 웹 서버

## 이 장에서 다룰 내용

- 여러 종류의 소프트웨어 및 하드웨어 웹 서버에 대해 조사
- HTTP 통신을 진단해주는 웹 서버를 `Perl`로 작성
- HTTP 트랜잭션을 웹 서버는 어떻게 처리하는지

## 다채로운 웹 서버

웹 서버는 HTTP 요청을 처리하고 응답을 제공

`웹 서버` 라는 용어는 웹 서버 소프트웨어와 웹 페이지 제공에 특화된 장비 둘다를 가리킨다.

`웹 서버`는 크기, 기능, 형태가 다르지만,

모든 웹 서버는 리소스에 대한 HTTP 요청을 받아 컨텐츠를 클라이언트에게 돌려준다.

### 웹 서버 구현

웹 서버는 HTTP 및 그와 관련된 TCP 처리를 구현한 것이다.

웹 서버는 자기 자신이 제공하는 리소스를 관리,

설정, 통제, 확장 하기위한 관리 기능을 제공

웹 서버는 TCP 커넥션 관리에 대한 책임을 운영체제와 나눠 갖는다.

### 웹 서버의 여러가지 형태

- `다목적 소프트웨어 웹 서버`를 표준 컴퓨터 시스템에 설치하고 실행이 가능
- 전자기기안에 컴퓨터 칩으로 구현된 웹 서버를 내장하여 `완전한 관리 콘솔`로 제공
  
### 다목적 소프트웨어 웹 서버

이 웹 서버는 네트워크에 연결된 표준 컴퓨터 시스템에서 동작

웹 서버 소프트웨어는 모든 컴퓨터와 운영체제에서 동작한다.

아래는 넷크래프트의 2021년 10월 조사자료 이다.

![스크린샷 2021-11-15 오후 9 08 56](https://user-images.githubusercontent.com/74235102/141779671-2f1404fe-1823-4ee6-9ad1-9fa77b6efe03.png)

### 임베디드 웹 서버

일반 소비자용 제품에 내장될 목적으로 만들어진 조그마한 웹 서버

## 간단한 펄 웹 서버

HTTP/1.1의 기능을 지원하려면 수많은 코드와 풍부한 리소스 지원, 가상 호스팅,
접근 제어, 로깅, 설정, 모니터링, 그 외 성능들을 위한 각종 기능이 필요하다.

최소한의 기능으로 동작하는 HTTP 서버라면 펄 코드로도 만들 수가 있다.

## 진짜 웹 서버가 하는 일

- 커넥션을 맺는다
  - 클라이언트 접속을 받아들임
  - 원하지 않는 요청이면 닫아버림
- 요청을 받음
  - HTTP 요청 메세지를 네트워크로부터 읽어들임
- 요청 처리
  - 요청 메세지를 해석하고 행동을 취함
- 리소스 접근
  - 메세지에서 지정한 리소스에 접근
- 응답 생성
  - 올바른 헤더를 포함한 HTTP 응답 메세지 생성
- 응답 보냄
  - 클라이언트에게 응답 내려줌
- 트랜잭션 로그
  - 로그파일에 트랜잭션 완료에 대한 기록을 남김

### 클라이언트 커넥션 수락

클라이언트가 이미 지속적 커넥션을 갖고 있다면, 그 커넥션을 사용 가능

아니라면, 서버에 대한 새 커넥션을 열어야 한다.

#### 새 커넥션 다루기

클라이언트가 웹 서버에 TCP 커넥션을 요청하면, 웹 서버는 커넥션을 맺고

TCP 커넥션에서 IP 주소를 추출하여 커넥션 맞은편에 어떤 클라이언트가 있는지 확인한다.

이 커넥션이 맺어지면 서버는 커넥션 목록에 이 커넥션을 추가하고

오가는 데이터를 지켜보기 위한 준비를 한다.

`웹 서버`는 어느 커넥션이든 마음대로 거절이나 즉시 닫을 수 있다.

#### 클라이언트 호스트 명 식별

웹 서버는 역방향 DNS를 사용하여 클라이언트 IP 주소를 호스트 명으로 변환하도록 설정이 되어있다.

웹 서버는 호스트 명을 구체적 접근 제어와 로깅을 위해 사용할 수 있다.

호스트명 룩업은 시간이 많이 걸릴 수 있어 웹 트랜잭션을 느리게 할 수 있다.

대용량 웹 서버들은 호스트명 분석을 꺼두거나 특정 컨텐츠에 한해서만 켜놓는다.

룩업 아파치 설정

```
HostnameLookups off
<Files ~ "\.(html|htm|cgi)$">
    HostnameLookups on
</Files>
```

#### ident를 통해 클라이언트 사용자 알아내기

몇몇 웹서버는 `IETF ident` 프로토콜을 지원한다.

`ident`프로토콜은 서버에게 어떤 사용자 이름이 HTTP 커넥션을 초기화했는지 알 수 있게 해준다.

> `ident`는 웹 서버 로깅에 유용

로그 포맷의 두번째 필드에 ident 사용자 이름을 담고있어서

조직 내부 폐쇄망에선 잘 사용할 수 있지만, 공공 인터넷의 경우에는 잘 동작하지 않는다.

- 많은 클라이언트 PC는 identd 데몬 소프트웨어를 실행하지 않음
- ident 프로토콜은 트랜잭션을 지연
- 방화벽이 이 트래픽을 막는 경우가 많다
- 안전하지 않고 조작하기 쉽다
- 가상 IP 주소를 잘 지원해주지 않음
- 사용자 이름의 노출로 인한 사적 데이터 침해

## 요청 메세지 수신

웹 서버는 네트워크 커넥션에서 데이터를 읽어 파싱하여 요청 메세지를 구성

<img width="408" alt="스크린샷 2021-11-20 오후 1 42 01" src="https://user-images.githubusercontent.com/74235102/142714676-f3037a67-bab5-422f-97c7-609121d3bff8.png">

> 요청 메세지 파싱

- 요청 메소드, URI, 버전 번호를 찾음
  - 값들은 띄어쓰기 한개로 분리가 되어있고 요청줄은 줄바꿈 문자열로 끝난다.
- 메세지 헤더를 읽는다.
  - 헤더는 CRLF(줄바꿈)으로 끝난다.
- 존재한다면 헤더의 끝을 의미하는 줄바꿈 빈줄을 찾아낸다.
- 요청 본문이 있다면 읽는다 (길이는 `Content-Length 헤더값`)

<img width="760" alt="스크린샷 2021-11-20 오후 1 48 10" src="https://user-images.githubusercontent.com/74235102/142714824-a618809a-f41b-4a87-a60e-4f28345b3673.png">

### 메시지의 내부 표현

<img width="643" alt="스크린샷 2021-11-20 오후 2 00 27" src="https://user-images.githubusercontent.com/74235102/142715082-6685bfdf-d5ac-4a6a-9c7e-9b56f0c40716.png">

### 커넥션 입/출력 처리 아키텍처

엡 서버는 아키텍처의 차이에 따라 요청을 처리하는 방식도 달라진다.

> 단일 스레드 웹 서버

한번에 하나씩 요청을 처리한다.

트랜잭션이 완료되면 다음 커넥션이 처리된다.

한 트랜잭션을 처리중이라면, **다른 요청들은 무시**가 되어 성능상 문제가 발생함

<img width="228" alt="스크린샷 2021-11-20 오후 2 03 39" src="https://user-images.githubusercontent.com/74235102/142715144-8004ad12-198b-4e2f-be68-1b4178066bf5.png">

> 멀티 프로세스와 멀티스레드 웹 서버

여러 프로세스와 스레드가 있기 때문에 여러 요청을 동시에 처리할 수 있다.

스레드는 필요할 때마다 생기거나 스레드 풀(Thread Pool)에서 가져와서 요청에 할당할 수 있다.

너무 많은 프로세스와 스레드가 생겨 리소스를 많이 소비하는 것을 막기 위해, 운영체제는 **스레드와 프로세스 최대 갯수에 제한**을 건다.

<img width="218" alt="스크린샷 2021-11-20 오후 2 10 45" src="https://user-images.githubusercontent.com/74235102/142715256-298b70d5-f1fb-4b76-b4e7-d400d0c56740.png">

> 다중 I/O 서버

다중 아키텍처에선 모든 커넥션들이 모든 활동들을 감시당한다.

커넥션이 할일이 있다면 그 커넥션에 대해 처리가 수행된다.

처리가 완료된 후 커넥션은 다음 작업을 위해 열린 커넥션 목록으로 돌아간다.

커넥션에 대해 작업을 수행하는건 실제로 해야할 일이 있을 때 수행.

스레드와 프로세슨는 유휴 상태의 커넥션에 매여 기다리느라 리소스 낭비를 하지 않는다.

> 다중 멀티스레드 웹 서버

멀티스레딩 + 다중화(multiplexing) 결합

여러개의 스레드는 열려있는 커넥션들을 감시하고 그 커넥션들에 대해 조금씩 작업 수행

## 요청 처리

웹서버가 요청을 받으면, 서버는 요청으로부터 메소드, 리소스, 헤더, 본문을 받아 처리한다.

## 리소스의 매핑과 접근

웹 서버는 리소스 서버

HTML 페이지나 이미지 파일들을 미리 만들어져 있는 콘텐츠를 제공해준다.

추가적으로 서버 위에 동작하는 리소스 생성 애플리케이션을 통해 만들어진 동적 컨텐츠도 제공

### Docroot

웹 서버는 여러 종류의 리소스 매핑을 지원하는데,

가장 기본 형태는 요청 URI를 웹 서버 파일 시스템 안에있는 파일 이름으로 사용하는 것이다.

이 예시를 드려고 도커로 nginx를 설치한 후에 진행

localhost:8080에 들어가면 기본적으로 index.html을 불러오는 설정이 nginx에서 되어있다.

> /etc/nginx/conf.d/default.conf

```
server {
    listen       80;
    listen  [::]:80;
    server_name  localhost;

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    }
}
```

Docroot는 `/usr/share/nginx/html`이 기본 루트값이 되겠고

`/` 그러니까 `localhost:8080/` 에 접속하게 되면 index.html이 반환되는 것이다.

그래서 해당하는 경로에 html파일이나 이미지 파일이 없게되면 `404 Not Found`를 출력하게 되는 모습이다.

<img width="1421" alt="스크린샷 2021-11-20 오후 2 33 11" src="https://user-images.githubusercontent.com/74235102/142715703-b98a41e6-9e6c-4bb7-8a81-923f35be8e0b.png">

#### 가상 호스팅된 docroot

이 방법은 한 서버로 2개 이상의 웹 사이트를 호스팅 할 수 있게 해주는 것이다.

> /etc/nginx/nginx.conf

```
http {
    ... 생략
    server {
    listen       80 default_server;
    listen       [::]:80 default_server;
    server_name  localhost;
    root         /usr/share/nginx/html;
    
            ... 생략
    }

    server {
        listen       8081;
        listen       [::]:8081;
        server_name  localhost;

        include /etc/nginx/default.d/*.conf;

        ... 생략
    }
}
```

이렇게 설정해주면 80포트에는 기존 nginx 서버가 돌아가면서

8081포트에는 우리가 설정해준 설정값들을 적용해서 다른 서비스도 돌아가게 된다.

#### 사용자 홈디렉토리 docroots

docroot의 또 다른 활용은 사용자들이 한대의 웹서버에서 각자의 개인 웹 사이트를 만들 수 있도록 해주는 것

`/~`다음에 사용자 이름들로 시작하는 URI는 개인 문서루트를 가리킨다.

### 디렉토리 목록

웹 서버는 경로가 파일이 아닌 디렉토리를 가리키는 디렉토리 URL에 대한 요청을 받을 수 있다.

웹 서버는 디렉토리 URL을 요청했을 때 몇 가지 다른 행동을 취하도록 할 수 있다.

- 에러를 반환한다.
- 디렉토리 대신 특별한 `색인 파일`을 반환
- 디렉토리를 탐색하여 그 내용을 담은 HTML페이지 반환

대부분의 웹서버는 요청한 URL에 대응되는 디렉토리 내에서 `index.html` 이나 `index.htm` 이라고 붙은 파일을 찾는다.

엔진엑스에서의 설정은

```
server {
    listen       80 default_server;
    listen  [::]:80 default_server;
    server_name  localhost;

    location (쓰고자 하는 경로) {
        root   /usr/share/nginx/html;
        autoindex on; (Directory Indexing 설정)
    }
}
```

### 동적 컨텐츠 리소스 매핑

웹 서버는 URI를 동적 리소스에 매핑할 수도 있다.

nginx는 따로 지원을 하지 않는다고 함

아파치는 URI의 경로가 `/cgi-bin/`으로 시작하면 `/usr/local/etc/httpd/cgi-programs/`에서 프로그램을 찾아 실행한다.

아파치 특정 확장자 파일만 실행하도록 설정

아래는 `.cgi`로 끝나는 모든 웹 리소스는 실행되어야 함을 명시하는 명령어

`AddHandler cgi-script .cgi`

### 서버사이드 인클루드(Server-Side Includes, SSI)

어떤 리소스가 `SSI`를 포함하고 있는 것으로 설정이 되어있다면, 서버는 그 리소스의 컨텐츠를 

클라이언트에게 보내기 전에 처리함

서버는 컨텐츠에 변수 이름이나 내장된 스크립트가 될 수 있는 어떤 특별한 패턴이 있는지 검사를 받는다.

특별한 패턴은 변수 값이나 실행 가능한 스크립트의 출력 값으로 치환된다.

### 접근제어

웹 서버는 각각의 리소스에 접근 제어를 할당할 수 있다.

접근 제어가 되고있는 리소스에 대한 요청이 도착하면 웹 서버는 클라이언트의 IP주소에 근거하여 접근을

제어하거나 또는 해당 리소스에 접근하기 위한 암호를 물어볼 수 있다.

## 응답 만들기

서버가 리소스를 식별하면, 서버는 요청 메소드로 서술되는 동작을 수행한 후 응답을 반환

응답 메세지는 `응답 상태코드`,`응답 헤더`, `응답 본문`을 포함한다.

### 응답 엔터티

트랜잭션이 응답 본문을 생성하면 그 내용을 응답 메세지와 함께 포함시켜 돌려준다.

응답 메세지는 다음을 포함한다.

- 응답 본문의 MIME을 서술하는 Content-Type 헤더 ex) `application/json`
- 응답 본문의 길이를 서술하는 Content-Length 헤더
- 응답 본문의 내용

### MIME 타입 결정하기

웹서버는 본문의 MIME 타입을 결정해야 한다.

> MIME타입과 리소스를 연결하는 방법

`mime.types`

MIME타입을 나타내기 위해 파일 이름의 확장자 사용할 수 있음.

웹 서버는 각 리소스의 MIME 타입을 계산하기 위해 확장자별 MIME타입이 담겨있는 파일 탐색

가장 흔한방법

`Magic Typing`

아파치 웹 서버는 각 파일의 MIME타입을 알아내기 위해 파일의 내용을 검사해서

알려진 패턴에 대한 테이블에 해당하는 패턴이 있는지 찾아볼 수 있음

**표준 확장자 없이 이름이 지어진 경우**에 편리

`유형 명시`

파일 확장자나 내용에 상관없이 특정 MIME타입을 갖도록 설정

`유형 협상`

한 리소스가 여러 종류의 문서 형식에 속하도록 설정할 수 있음

특정 파일이 특정 MIME타입을 갖게끔 설정도 가능

### 리다이렉션

성공 메세지 대신 리다이렉션을 반환할 때가 있음 (예 - Oauth2 로그인)

리다이렉션 응답은 300번대 상태코드로 지칭

Location 응답 헤더는 컨텐츠의 선호하는 위치에 대한 URI를 포함한다.

다음의 경우에 리다이렉션이 유용하다

- 영구히 리소스가 옮겨진 경우
- 임시로 리소스가 옮겨진 경우
- URL 증강
- 부하 균형
- 친밀한 다른 서버가 있을 때
- 디렉터리 이름 정규화

## 응답 보내기

서버는 여러 클라이언트에 대한 많은 커넥션을 가질 수 있음

서버는 커넥션 상태를 계속 추적해야 하며 지속적 커넥션은 주의해서 다뤄야 함

비 지속적 커넥션이라면 모든 메세지 전송 후 자신쪽의 커넥션을 닫을 것임

지속적 커넥션이라면, 서버가 Content-Length 헤더를 바르게 계산하기 위해 특별한 주의를 필요로 하는 경우,

클라이언트가 응답이 언제 끝나는지 알 수 없는 경우에 커넥션은 열린상태 유지

## 로깅

트랜잭션이 완료되었을 때 웹서버는 트랜잭션이 어떻게 수행되었는지에 대한 로그를 로그파일로 기록한다.

로깅에 대한 여러가지 설정 양식도 제공한다.

nginx에서의 logging 설정은

`access_log  /var/log/nginx/access.log`
`error_log /var/log/nginx/error.log`

![스크린샷 2021-11-21 오전 12 16 43](https://user-images.githubusercontent.com/74235102/142731674-2e7979ca-5d8a-472c-880f-6f1c01ce94da.png)
