# 10장 HTTP/2.0

# 목차
- 10.1 HTTP/2.0의 등장 배경
- 10.2 HTTP/2.0 특징
    - 10.2.1 바이너리 프레이밍 계층
    - 10.2.2 스트림, 메시지 및 프레임
        - 스트림
        - 메시지
        - 프레임
    - 10.2.3 요청 및 응답 다중화
    - 10.2.4 스트림 우선순위 지정
    - 10.2.5 서버 푸시
        - PUSH_PROMISE
    - 10.2.6 헤더 압축
    - 10.2.7 이 외에 HTTP/2.0의 장점
- 10.3 HTTP/1.1 vs HTTP/2.0 성능 비교
    - 10.3.1 성능 비교 결과
- 10.4 최근에 HTTP/2.0과 관련하여 발생한 보안 이슈
- 10.5 참고 자료

# 10.1 HTTP/2.0의 등장 배경
- 이전 버전의 HTTP 프로토콜은 의도적으로 단순한 구현을 위해 고안되어습니다.
- 그러나 단순한 구현을 위해 애플리케이션 성능을 희생해야 했습니다.
    성능과 관련하여 예를 들면,
    1. HTTP/1.x는 커넥션 하나를 통해 요청 하나를 보내고 그에 대해 응답 하나만을 받는 메시지 교환 방식을 사용합니다.
    2. 그래서 HTTP/1.x 클라이언트는 동시성을 실현하고 지연 시간을 줄이기 위해 여러 개의 커넥션(연결)을 사용해야 합니다.
    3. HTTP/1.x는 요청 및 응답 헤더를 압축하지 않으므로 불필요한 네트워크 트래픽이 발생합니다.
    4. 리소스 우선순위 지정을 허용하지 않으므로 기본 TCP 연결을 효율적으로 사용할 수 없습니다. 
- 또한 오늘날의 웹은 웹 페이지를 로딩할 때 받아야하는 리소스의 크기도 커졌고, 과거에 비해 웹이 매우 동적으로 동작하며, 보안 또한 중요해졌습니다. 이러한 이유들 때문에 HTTP/2.0이 고안되었습니다.
- HTTP/2.0은 전송 지연(latency)을 줄이고 성능 개선에 초점을 맞추고 있습니다. 
- 참고로 상당한 성능 향상을 보여준 구글의 SPDY 초안을 기반으로 HTTP/2.0 초안이 만들어졌습니다.

    <details>
    <summary>📌참고 - SPDY란?</summary>
    - 2009년 구글에서 개발한 시험용 프로토콜
    - 이 프로토콜의 목표는 HTTP/1.1의 알려진 성능 제한을 해결하여 웹페이지의 로드 지연 시간을 줄이는 것잆니다.
    - 주요 기능으로는 헤더 압축, 적은 수의 커넥션으로 다수의 요청과 응답을 동시에 처리(Multiflexing, 다중 전송), 서버 푸시, 스트림 우선 순위 등이 있습니다. 
    - 대부분의 SPDY 장점은 HTTP/2에 포함돼 있기 때문에 SPDY 지원을 중단하기로 결정했고, 2016년 초에 지원이 중단되었습니다.

    이 외에도 SPDY와 관련하여 더 많은 내용을 알고싶으시다면 [SPDY는 무엇인가?](https://d2.naver.com/helloworld/140351)와 [SPDY 및 HTTP/2의 간략한 역사](https://developers.google.com/web/fundamentals/performance/http2?hl=ko#spdy_%EB%B0%8F_http2%EC%9D%98_%EA%B0%84%EB%9E%B5%ED%95%9C_%EC%97%AD%EC%82%AC)를 참고해주세요 :)
    <details>

# 10.2 HTTP/2.0 특징
- 특징을 알기에 앞서, HTTP/2.0은 이전의 HTTP 표준을 대체하는 것이 아니라 확장한다는 것입니다. HTTP의 애플리케이션 의미 체계는 동일하게 유지되며, 제공되는 기능이나 핵심 개념(예: HTTP 메서드, 상태 코드, URI 및 헤더 필드)은 변경되지 않습니다.
- HTTP/2.0은 성능 향상에 초점을 맞춘 프로토콜로 보면 좋을 것 같습니다.
- 아래에 소개되는 특징은 HTTP/1.x 버전과 다른 부분들이기 때문에 차이점이라고 생각하셔도 됩니다 :)

## 10.2.1 바이너리 프레이밍 계층
![바이너리 프레이밍 계층](https://developers.google.com/web/fundamentals/performance/http2/images/binary_framing_layer01.svg?hl=ko)
- HTTP/2의 모든 성능 향상 중 핵심은 **바이너리 프레이미 계층**입니다.
- 이 계층은 HTTP 메시지가 캡슐화되어 클라이언트와 서버 사이에 전송되는 방식을 규정합니다.
- HTTP 의미 체계(ex.동사, 메서드 및 헤더)는 영향을 받지 않지만 정송 중에 이 의미 체계가 **인코딩되는 방식은 다릅니다.**
    - HTTP/1.x : 줄바꿈으로 구분되는 일반 텍스트
    - HTTP/2 : 더 작은 메시지와 프레임으로 분할되며, 각각 바이너리 형식으로 인코딩
- 클라이언트와 서버는 서로를 이해하기 위해 새 바이너리 인코딩 메커니즘을 사용해야 합니다.

## 10.2.2 스트림, 메시지 및 프레임
- 바이너리 프레이밍 메커니즘이 도입됨에 따라 클라이언트와 서버 간에 데이터 교환 방식이 바뀌었습니다.
![스트림, 메시지 및 프레임](https://developers.google.com/web/fundamentals/performance/http2/images/streams_messages_frames01.svg?hl=ko)

### 스트림
- 구성된 커넥션 내에서 전달되는 양방향 흐름이며, 하나 이상의 메시지가 전달될 수 있습니다.
- 한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어집니다.
  예를 들면, 
  1. 클라이언트가 새 스트림을 만들어 이를 통해 HTTP 요청을 보냅니다. 
  2. 요청을 받은 서버는 이 요청과 같은 스트림으로 응답을 보냅니다. 
  3. 그러고 나면 스트림이 닫힙니다.
- 각 스트림에는 양방향 메시지 전달에 사용되는 고유 식별자와 우선순위 정보(선택 사항)가 있습니다.
- 모든 통신은 단일 TCP 연결을 통해 수행되며 전달될 수 있는 양방향 스트림의 수는 제한이 없습니다. 

### 메시지
- 요청 또는 응답 메시지에 매핑되는 프레임의 전체 시퀀스입니다.
- 각 메시지는 하나의 HTTP 메시지(ex. 요청 또는 응답)이며 하나 이상의 프레임으로 구성됩니다.


### 프레임
- HTTP/2에서 통신의 최소 단위, 각 최소 단위에는 하나의 프레임 헤더가 포함됩니다. 이 프레임 헤더는 최소한으로 프레임이 속하는 스트림을 식별합니다. 
- 특정 유형의 데이터(ex. HTTP 헤더, 메시지 페이로드 등)를 전달합니다.

## 10.2.3 요청 및 응답 다중화
![요청 및 응답 다중화](https://developers.google.com/web/fundamentals/performance/http2/images/multiplexing01.svg?hl=ko)
- 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있습니다. 
  즉, 여러 개의 요청이 동시에 보내질 수 있다는 의미입니다.
    - 기존 HTTP/1.x에서 성능 개선을 위해 클라이언트가 여러 병렬 요청을 수행하려는 경우, 여러 TCP 연결이 사용되어야 합니다.
      이는 HOL(Head-of-Line) 차단과 TCP 연결의 비효율적인 사용을 초래합니다.
    <details>
    <summary>📌참고 - HOL 차단 (Head Of Line Bloking)</summary>
    응답순서는 보장되어야하기 때문에 앞의 요청을 처리하는데 많은 시간이 소요될 때 뒤의 요청들이 늦게 응답 받게되는 현상
    </details>
- 전체 요청 및 응답 다중화 지원을 위해 클라이언트와 서버가 HTTP 메시지를 독립된 프레임으로 세분화하고, 이 프레임을 끼어들기(interleaving, 인터리빙)한 다음, 다른 쪽에서 다시 조립하도록 허용합니다. 이러한 기능은 HTTP/2에서 가장 중요한 기능 향상입니다. 
    - 이 기능을 통해 다음과 같은 작업이 가능합니다.
    1. 여러 요청 혹은 여러 응답을 하나도 차단하지 않고 병렬로 끼어들기(인터리빙)를 할 수 있습니다.
    2. 단일 연결을 사용하여 여러 요청과 응답을 병렬로 전달할 수 있습니다.
    3. 불필요한 HTTP/1.x 임시 방편을 제거합니다. (ex. 연결된 파일, image sprites, 도메인 분할)
    4. 불필요한 지연 시간을 제거하고, 사용할 수 있는 네트워크 용량의 활용도를 개선하여 페이지 로드 시간을 줄입니다. 
- 애플리케이션이 더 빠르고 단순해지고 배포 비용이 절감됩니다. 

## 10.2.4 스트림 우선순위 지정
- 네트워크 대역폭이 충분하지 않아 프레임의 전송이 느리다면, 웹브라우저는 보다 중요한 리소스(ex. 이미지 파일보다 HTML 페이지)를 요청하는 스트림에게 더 높은 우선 순위를 부여할 수 있습니다. 
- 그러나 클라이언트는 스트림 우선 순위 지정을 사용하여 특정 순서로 스트림을 처리하도록 서버에게 강요할 수 없습니다. 그래서 요청이 우선순위대로 처리된다는 보장은 없습니다. 

## 10.2.5 서버 푸시
- 서버는 원래 요청에 응답할 뿐만 아니라 클라이언트가 명시적으로 요청하지 않아도 서버가 추가적인 리소스를 클라이언트에 푸시할 수 있습니다. 
- 서버는 어떤 리소스가 클라이언트에 필요한지 이미 알고 있습니다.
- 이는 클라이언트가 HTML 문서를 파싱해서 필요한 리소스를 다시 요청하여 발생하게 되는 지연 시간과 트래픽을 줄여줍니다. 
- 실제로 아래와 같이 데이터 URI를 통해 리소스를 인라인 처리한 적이 있다면 이미 서버 푸시를 체험한 것입니다. 
  ```
  <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAA
          AAAAAACH5BAAAAAAALAAAAAABAAEAAAICTAEAOw=="
     alt="1x1 transparent (GIF) pixel" />
  ```
- HTTP/2에서는 클라이언트가 서버 푸시의 사용 방식을 완벽하게 제어합니다. 
  예를 들면 다음과 같습니다.
  - 동시에 푸시되는 스트림의 수 제한
  - 스트림이 최초로 열릴 때 푸시되는 데이터의 크기를 제어하는 초기 흐름 제어 창을 조정
  - 서버 푸시를 완전히 비활성화
- 푸시된 각 리소스는 인라인 처리된 리소스와는 다른 스트림이며, 클라이언트에 의해 개별적으로 다중화, 우선순위 지정 및 처리가 가능합니다. 
- 푸시된 리소스가 동일 출러 정책을 준수해야 합니다. 제공된 콘텐츠에 대해 서버를 신뢰할 수 있어야 합니다. 
### PUSH_PROMISE
- 리소스에 대해 중복 요청이 생성되는 것을 막기 위해 클라이언트는 서버가 어떤 리소스를 푸시할지를 알아야 합니다. 
- 이러한 요구사항을 충족시키는 가장 단순한 전략은 약속했던 리소스의 HTTP 헤더만 포함된 모든 PUSH_PROMISE 프레임을 상위 요소의 응답(DATA 프레임)보다 먼저 전송하는 것입니다. 

## 10.2.6 헤더 압축
- 요즘에는 웹페이지 하나를 보기 위해 수십에서 수백 번의 요청을 보내기 때문에 HTTP/1.1에서 전송하는 헤더의 크기가 전송 지연과 대역폭 양쪽 모두에 실질적인 영향을 끼치게 되었습니다. 
- 처리 시간을 줄이고, 성능을 개선하기 위해 HTTP/2.0에서는 HPACK 압축 형식을 사용하여 요청 및 응답 헤더 메타데이터를 압축합니다. 
    <details>
    <summary>참고 - HPACK 압축 알고리즘</summary>
    - 검색된 보안 문제를 해결
    - 구현이 효율적이고 단순
    - HTTP 헤더 메타데이터의 압축이 뛰어나도록 설계됨.
    이와 더 관련된 내용은 [HPACK의 보안 성능](https://developers.google.com/web/fundamentals/performance/http2?hl=ko#hpack%EC%9D%98_%EB%B3%B4%EC%95%88_%EB%B0%8F_%EC%84%B1%EB%8A%A5)과 [HPACK-HTTP/2의 헤더 압축](https://tools.ietf.org/html/draft-ietf-httpbis-header-compression)을 참고해주세요 :)
    </details>

## 10.2.7 이 외에 HTTP/2.0의 장점
- HTTP/2.0에서는 동일한 연결을 재사용하여 각 TCP 연결을 더 효율적으로 사용할 수 있고, 전반적인 프로토콜 오버헤드를 대폭 줄일 수 있습니다. 
- 또한 더 적은 연결을 사용하므로 전체 연결 경로에서 메모리와 처리량이 줄어듦에 따라 전체 운영 비용이 절감되고 네트워크 활용도와 용량이 개선됩니다. 
- 그래서 HTTP/2.0으로 전환하면 네트워크 지연 시간이 줄어들 뿐만 아니라 처리량이 개선되고 운영 비용이 줄어듭니다. 

# 10.3 HTTP/1.1 vs HTTP/2.0 성능 비교
[https://www.httpvshttps.com/](https://www.httpvshttps.com/) 사이트를 통해 캐시되지 않은 360개의 이미지를 http/1.1과 HTTP/2.0 환경에서 로드를 시키려고 할 때 로드되는 시간이 얼마나 걸리는지 확인을 함으로써 속도를 비교할 수 있는 사이트 입니다. 

참고로 HTTP와 HTTPS라고 표기되어있자만 실제로 개발자 도구의 네트워크 탭을 통해 확인해보면 각각 HTTP/1.0과 HTTTP/2.0이 사용되고 있다는 것을 볼 수 있습니다. 

## 10.3.1 성능 비교 결과
HTTP/2.0이 HTTP/1.1 보다 67%나 더 빠르다는 것을 확인할 수 있습니다. (여기서 측정된 속도는 인터넷 환경에 따라 다를 수 있습니다.)
<img src="./img_나현/HTTP 테스트.png" alt="request 데이터 블록.png" /> 
<img src="./img_나현/HTTPS 테스트.png" alt="request 데이터 블록.png" /> 

# 10.4 최근에 HTTP/2.0과 관련하여 발생한 보안 이슈
- 넷플릭스와 아마존 로드 밸런서라는 앱에서 HTTP/2와 HTTP/1.1 버전을 혼합해서 사용하고 있어서 보안에 취약한 부분이 발생한 일이 있었습니다. 
- 그리고 이렇게 사용하는 조직이 생각보다 비현실적으로 많다고 합니다. 
- 이러한 취약점을 발견한 케틀이란 포트스위거의 연구 책임자가 HTTP/2와 관련된 취약점을 네트워크에서 탐지할 수 있게 도와주는 도구인 HTTP 리퀘스트 스머글러(HTTP Request Smuggler)를 발표하기도 했는데 이 툴은 [여기 깃허브](https://github.com/PortSwigger/http-request-smuggler) 페이지에서 열람 및 다운로드를 할 수 있습니다.
- 이와 관련된 자세한 이야기는 [이 뉴스](https://www.boannews.com/media/view.asp?idx=99638)를 참고해주세요 :)

# 10.5 참고 자료
- [HTTP/2 소개](https://developers.google.com/web/fundamentals/performance/http2?hl=ko)
- [HTTP/2의 탄생 배경과 특징](https://americanopeople.tistory.com/115)
- [나만 모르고 있던 HTTP/2(HTTP/2 설명과 HTTP/1.1 VS HTTP/2 성능 비교)](https://www.popit.kr/%EB%82%98%EB%A7%8C-%EB%AA%A8%EB%A5%B4%EA%B3%A0-%EC%9E%88%EB%8D%98-http2/)
- [HOL 차단관련 설명](https://velog.io/@hoo00nn/HTTP1.1-vs-HTTP2.0)
- [리소스 인라인 처리](https://hpbn.co/http1x/#resource-inlining)